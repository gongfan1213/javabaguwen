### 第1章 Java基础知识
#### 1.1 数据类型
### 1.1.1 为什么要设计封装类，Integer和int有什么区别
- **难度指数**：★★★
- **考查频率**：45%
- **开发年限**：1 - 3年
- **视频解说**：Mic
- **匹配岗位**：中级开发工程师 
- **扫码看解说**

这是一个典型的Java基础问题，从本质上来说，这个问题是在考查求职者对于面向对象的理解程度。同时也是在考查求职者的基本功，越是简单常见的东西，就越能体现求职者的基础知识的扎实程度。

这类问题一般用来考查有1 - 3年开发经验的程序员。在回答这个问题的时候，尽量从封装类型的特性和功能上全方位地回答。

Integer是基本数据类型int的封装类。在Java里面，有8种基本数据类型，它们都有一一对应的封装类型。基本数据类型和封装类型的区别有很多，比如int类型，我们可以直接定义一个变量名并赋值，但是Integer类型需要使用new关键字创建对象基本类型，和Integer类型混合使用时，Java会自动通过拆箱和装箱实现类型转换。而Integer作为一个对象类型，封装了一些方法和属性，我们可以利用这些方法来操作数据。作为成员变量，Integer变量的默认值是null，而int变量的默认值是0，要是真正罗列出来，还可以挖掘出更多的差异点。

在Java里面，之所以要对基础类型设计一个对应的封装类型，是因为Java本身是一门面向对象的语言，对象是Java的基础操作单元，我们时时刻刻都在创建对象，也随时都在使用对象。很多时候传递数据也需要对象类型，比如ArrayList、HashMap这些集合，只能存储对象类型，因此封装类型存在的意义就很大。此外，封装类型还有很多好处，比如安全性较好，可以避免外部操作随意修改成员变量的值，保证了成员变量和数据传递的安全性；隐藏了实现细节，对使用者更加友好，只需要调用对象提供的方法就可以完成对应的操作。


Integer和int的区别有很多，简单总结为3个方面：

1. Integer的初始值是null，int的初始值是0。

2. Integer存储在堆内存，int直接存储在栈空间。 

3. Integer是对象类型，它封装了很多的方法和属性，我们在使用的时候更加灵活。 


**面试点评**

Java相关职业，不管是初级开发工程师还是高级开发工程师，应该给求职者月薪15000元还是30000元，并没有行业标准，企业只能针对求职者的工作背景及技术深度进行考查。

这个问题显然也在考查Java基础，它是大家在工作中最常涉及，但很少深度研究的内容，建议求职者多关注Java基础方面的内容。

### 1.1.2 为什么“1000==1000”为false，“100==100”为true
- **难度指数**：★★★★
- **考查频率**：30%
- **开发年限**：1 - 3年
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师 
- **扫码看解说**

有位小伙伴在维护代码过程中，出现了一个莫名其妙的问题。明明上线之后程序跑得还好好的，可程序上线运行一段时间之后，发现运行结果和期望值恰好相反。因为涉及资金，造成了比较大的损失，最后，这位小伙伴被公司辞退了。我们来看看这位小伙伴“背的这个锅”值不值？他的代码大致是这样写的：

```java
public boolean xxx(Integer a,Integer b){
   ...
    if(a == b){
       ...
        return true;
    }
   ...
    return false;
}
```

一般情况下，a和b都输入100的时候，返回为true，但当a和b都输入1000的时候，返回为false。按照正常逻辑理解，100等于100，那么1000为什么不等于1000呢？这位小伙伴百思不得其解。于是，他写了一段测试代码：

```java
Integer a = 100,b = 100,c = 1000,d = 1000;
System.out.println((a == b) + "," + (c == d));
```

运行结果是：true，false。这到底是什么原因呢？我们对照Integer的源码来进行分析：

```java
public final class Integer extends Number implements Comparable<Integer> {
   ...
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
   ...
}
```

以上是从Integer的源码中摘取的片段，它有一个valueOf()方法。我们发现，valueOf()方法做了一个条件判断，其中IntegerCache.low的值为 - 128，IntegerCache.high的值为127。也就是说，如果目标值在 - 128~127之间，会直接从cache数组中取值，否则就会新建对象。

而在上面的案例中，我们通过这样的形式Integer a = 100来定义变量时，Java默认会调用Integer.valueOf()方法进行装箱操作，相当于变成了这样的结构：Integer a = Integer.valueOf(100)。于是，就触发了IntegerCache中的缓存设计，使得最终的执行结果为true。

可是为什么默认值是 - 128~127，而不是 - 200~200或者其他值呢？JDK为何要这样做呢？

Java API中是这样解释的：
```
Returns an Integer instance representing the specified int value. If a new Integer instance is not required, this method should generally be used in preference to the constructor Integer(int), as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range.
```
翻译过来的大致意思是：

- 128~127的数据在int范围内是使用最频繁的，为了减少频繁创建对象带来的内存消耗，这里其实用了享元模式，以提高空间和时间上的性能。

其实在JDK中，这样的应用不止int，下表中的其他类型也都应用了享元模式，也就是说对数值做了缓存，只是缓存的范围不一样，具体如下表所示。

|基本类型|大小|最小值|最大值|包装器类型|缓存范围|是否支持自定义|
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|boolean| - | - | - |Boolean| - | - |
|char|16bit|Unicode 0|Unicode 2(16)-1|Character|0~127|否|
|byte|8bit| - 128|127|Byte| - 128~127|否|
|short|16bit| - 2(15)|2(15)-1|Short| - 128~127|否|
|int|32bit| - 2(31)|2(31)-1|Integer| - 128~127|支持|
|long|64bit| - 2(63)|2(63)-1|Long| - 128~127|否|
|float|32bit|IEEE754|IEEE754|Float| - | - |
|double|64bit|IEEE754|IEEE754|Double| - | - |
|void| - | - | - |Void| - | - |

**面试点评**

对Java基础有深度的理解是很重要的：一个小小的知识点，可能在生产环境中有较大的影响。所以一些大厂在面试中对基础知识的考查比例会比较大。

Integer中的享元模式采用了一种空间换时间的设计理念，在Java生态中很多地方都采用了类似的理念，比如ThreadLocal、本地缓存等，大家可以先学习这些理念，再将其转变成自己的能力。 

### 1.1.3 new String("hello")之后，到底创建了几个对象
- **难度指数**：★★★★★
- **考查频率**：40%
- **开发年限**：1 - 3年
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师 
- **扫码看解说**

首先，这个语句里面有一个new关键字，这个关键字是在程序运行时，根据已经加载的系统类String，在堆内存里面实例化的一个字符串对象。

![image](https://github.com/user-attachments/assets/fd42e2ae-36be-4f64-bc2b-f7517d08a7bf)


然后，在这个String的构造方法里面，传递了一个hello字符串，因为String里面的字符串成员变量是final修饰的，所以它是一个字符串常量。

接下来，JVM会用字面量hello去字符串常量池里面试图获取它对应的String对象引用，如果获取不到，就会在堆内存里面创建一个hello的String对象，并且把引用保存到字符串常量池里面。

后续如果再有字面量hello的定义，因为字符串常量池里面已经存在了字面量hello的引用，所以只需要从常量池里面获取对应的引用就可以了，不需要再创建。

所以，对于这个问题，分以下两种情况：
1. 如果hello这个字符串常量不存在，则创建两个对象，分别是hello这个字符串常量，以及new String这个实例对象。
2. 如果hello这个字符串常量存在，则只会创建new String()这一个实例对象。

再来看这样一段代码：
```java
public static void main(String[] args) {
    String s1 = "hello";
    String s2 = "hello";
    String s3 = "he" + "llo";
    String s4 = "hel" + new String("lo");
    String s5 = new String("hello");
    String s6 = s5.intern();
    String s7 = "h";
    String s8 = "ello";
    String s9 = s7 + s8;
}
```

以上代码的输出结果如下：
```java
System.out.println(s1==s2);//true
System.out.println(s1==s3);//true
System.out.println(s1==s4);//false
System.out.println(s4==s5);//false
System.out.println(s1==s9);//false
System.out.println(s1==s5);//false
System.out.println(s1==s6);//true
```

接下来简单分析一下，由于s2指向的字面量hello在常量池中已经存在（s1先于s2），于是JVM就返回这个字面量绑定的引用，所以s1==s2。

s3中字面量的拼接其实就是hello，在编译期间就已经对它进行了优化，所以s1和s3也是相等的。

s4中的new String("lo")生成了两个对象：lo和new String("lo")。lo存在于字符串常量池中，new String("lo")存在于堆中，String s4 = "hel" + new String("lo")实质上是两个对象的相加，编译器不会进行优化，相加的结果存在于堆中，而s1存在于字符串常量池中，当然不相等。s1==s9的原理也一样。

对于s4==s5，因为两个相加的结果都在堆中，不用说，肯定不相等。

对于s1==s6，s5.intern()方法能使一个位于堆中的字符串，在运行期间动态地加入字符串常量池（字符串常量池的内容是在程序启动的时候就已经加载好了的）。如果字符串常量池中有该对象对应的字面量，则返回该字面量在字符串常量池中的引用；否则，复制一份该字面量到字符串常量池并返回它的引用。因此s1==s6输出true。

**面试点评**

现在的技术面试也偏向于体系化地考查方式，不再是点状式地提问，必须要对JVM里面的运行时内存划分及JVM常量池有足够深刻的理解，这也涉及享元模式在JDK源码中的应用。

面试官想通过这个问题考查求职者对Java字符串的内部实现、字符串常量、类加载机制及对象的创建原理的理解。

### 1.1.4 String、StringBuffer、StringBuilder的区别是什么
- **难度指数**：★★★★★
- **考查频率**：60%
- **开发年限**：1 - 3年
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师 
- **扫码看解说**

关于String、StringBuffer、StringBuilder的区别，可以从以下4个方面来理解。

1. **值可变性方面**

String内部的value值是final修饰的，所以它是不可变类。因此，每次修改String的值，都会产生一个新的对象。而StringBuffer和StringBuilder是可变类，它们在字符串变更的时候，不会产生新的对象。

2. **线程安全方面**

String是不可变类，所以它是线程安全的。

StringBuffer是线程安全的，因为它的每个操作方法都加了synchronized关键字。

StringBuilder不是线程安全的。如果在多线程环境下对字符串进行操作，建议使用StringBuffer，在单线程情况下才建议使用StringBuilder。

3. **性能方面**

String的性能是最低的，因为它不可变，意味着在做字符串拼接和修改的时候，需要反复地重新创建新的对象和分配内存。

其次是StringBuffer，它要比String性能高，因为它的可变性使得字符串可以直接被修改。

性能最高的是StringBuilder，因为StringBuffer加了同步锁，而StringBuilder是无阻塞的。

4. **数据存储方面**

String存储在字符串常量池中，而StringBuffer和StringBuilder存储在堆内存中。



最后补充一下，StringBuilder和StringBuffer都派生于AbstractStringBuilder抽象类。


**面试点评**

这个问题其实还是挺有意思的。我们平时在使用字符串操作的时候可能并不会关心性能及线程安全。但是Java确实提供了不同的字符串操作，使得我们可以在不同的场景中使用不同的字符串对象。这些小细节在开发中或多或少还是会有一些影响的。

### 1.2 Object对象
#### 1.2.1 如何理解Java对象的创建过程
- **难度指数**：★★★★★
- **考查频率**：40%
- **开发年限**：3 - 5年
- **视频解说**：Mic
- **匹配岗位**：中级开发工程师、高级开发工程师 
- **扫码看解说**

![image](https://github.com/user-attachments/assets/9ce090c9-74d9-4f3e-ad42-df2c10a947b6)


一个工作了5年的Java程序员，第一面就被问到了这样一个问题。其实在实例化一个对象的时候，JVM首先会去检查目标对象是否已经被加载并初始化了。

如果没有，则JVM需要立刻去加载目标类，然后调用目标类的构造器完成初始化。目标类的加载是通过类加载器来实现的，主要就是把一个类加载到内存里面。

然后，初始化主要是对目标类里面的静态变量、成员变量、静态代码块进行初始化。当目标类被初始化以后，就可以从常量池里面找到对应的类元信息，并且目标对象的大小在类加载之后就已经确定了，所以这个时候就需要为新创建的对象，根据目标对象的大小在堆内存里面分配内存空间。

内存分配的方式一般有两种，一种是指针碰撞，另一种是空闲列表，JVM会根据Java堆内存是否规整来决定内存分配方式。

接下来，JVM会把目标对象里面的普通成员变量初始化为零值，比如int类型初始化为0，对象类型初始化为null（类变量在类加载的准备阶段就已经初始化过了）。这一步操作主要是保证对象里面的实例字段不用初始化就可以直接使用，也就是程序能够获得这些字段对应数据类型的零值。

然后，JVM还需要对目标对象的对象头做一些设置，比如对象所属的类元信息、对象的GC分代年龄、hashCode、锁标记等。

完成这些步骤以后，对于JVM来说，新对象的创建工作就完成了。但是对于Java语言来说，对象创建才算开始。

接下来要做的，就是执行目标对象内部生成的init方法，初始化成员变量的值，执行构造块，最后执行目标对象的构造方法，完成对象的创建。

其中，init方法是Java文件编译之后在字节码文件中生成的，它是一个实例构造器，这个构造器会把语句块、变量初始化、调用父类构造器等操作组织在一起。所以调用init方法能完成一系列初始化动作。

**面试点评**

这个问题显然也在考查JVM的底层原理，这恰恰是我们平时接触最多但研究最少的内容。面试官之所以对Java基础考查得这么深入，本意上除了做人员筛选，也是考虑在企业的开发工作中如何编写稳定、可靠的程序。

#### 1.2.2 什么是深克隆和浅克隆
- **难度指数**：★★★★★
- **考查频率**：70%
- **开发年限**：3 - 5年
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师、高级开发工程师 
- **扫码看解说**

一个工作了3年的小伙伴面试时被问到这样一个问题：谈谈你对深克隆和浅克隆的理解。他回答说深克隆是克隆值，浅克隆是克隆引用，当时他只说了这样一句话，回答完以后，他看到面试官的表情很诧异，面试官也没有继续深入追问了，你们知道这个求职者的问题出在哪里吗？

说到克隆就不得不提到一种设计模式——原型模式。我们先来看原型模式的定义，原型模式的官方定义原文是这样的：
```
Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.
```
大致意思是，原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。其实复制、克隆、拷贝表达的都是同一个意思。因为Java中的数据类型分为引用类型和值类型，因此，在克隆数据的过程中，就有了深克隆和浅克隆。


那么，深克隆和浅克隆的本质区别是什么呢？可以将其归纳为以下两点：

1. 克隆数据后两者之间是否有关联。

2. 改变一个值是否会影响另一个值。



那么，到底什么是深克隆，什么是浅克隆呢？



先来看浅克隆，浅克隆是指复制一个对象时，只会复制对象本身以及其引用类型成员的引用，而不复制引用指向的对象本身。这意味着，新的对象与原始对象共享相同的属性，因此，如果在其中一个对象中更改属性，那么另一个对象也将受到影响，一方数据变化，另一方会跟着变化。


如下图所示，有原型对象Object，它是引用类型，然后克隆产生两个克隆对象obj1和obj2，只是它们克隆的是Object的内存地址，因此obj1和obj2都指向Object，那么Object中的成员变量值发生改变时，obj1和obj2的成员变量值也就会发生改变。


![image](https://github.com/user-attachments/assets/5569c1d1-41c9-439b-84b1-557173dd512d)



浅克隆常用的API有以下3种。

1. 工具类BeanUtils和PropertyUtils。BeanUtils是Spring提供的，PropertyUtils是Apache的commons包中提供的，二者的对比如下表所示。

|  |Spring的BeanUtils|commons的PropertyUtils|
| ---- | ---- | ---- |
| 方法 |copyProperty和copyProperties|copyProperties|
| 参数 |src, dest|dest, src|

2. 实现Cloneable接口。

3. Arrays的copyOf()方法。

下面来看深克隆，深克隆是指复制一个对象时，不是复制该对象的地址，而是递归复制该对象所有引用类型成员的副本。这意味着，新的对象是完全独立于原始对象的，如果在其中一个对象中更改属性，另一个对象不会受影响。如下图所示，obj1和obj2分别指向不同的原型对象，复制的是值而不是内存地址。

深克隆常用的API有以下5种：

1. 重写clone()方法，每个对象都要实现Cloneable接口并重写Object类中的clone()方法。

2. 序列化，必须实现Serializable接口。

3. Apache commons工具包SerializationUtils.clone(T object)。

4. 通过JSON工具类实现深克隆。

5. 通过构造方法实现深克隆，也就是手动“new”对象。

![image](https://github.com/user-attachments/assets/e8d48a51-7351-433c-8cea-c2770e12d516)


**面试点评**

这个问题属于Java基础范畴，它很重要。如果不小心用错了克隆方法，就会导致多个线程同时操作一个对象而产生数据安全问题。

面试官通过这个问题考查求职者对对象克隆的理解。求职者要知道深克隆和浅克隆的底层区别，并知道如何实现深克隆。求职者还要知道根据实际场景和需求，权衡克隆过程中的性能、资源消耗和对象关系的复杂性的影响，并选择合适的克隆方式。

#### 1.2.3 强引用、软引用、弱引用、虚引用有什么区别
- **难度指数**：★★★★★
- **考查频率**：50%
- **开发年限**：3 - 5年
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师、高级开发工程师 
- **扫码看解说**

一位工作了4年的小伙伴面试时被问到这样一道题：Java中的4种对象引用之间的区别是什么？这道面试题问得比较偏门，相关知识更多应用在一些底层类库或者框架中，涉及的知识点包括JVM、GC等，一般人确实很少关注。Java中的4种引用类型包括强引用、软引用、弱引用、虚引用。它们主要体现对象不同的可达性状态和对GC的影响。下面给大家详细地分析 


### 1.2.3 强引用、软引用、弱引用、虚引用有什么区别
- **难度指数**：★★★★★
- **考查频率**：50%
- **开发年限**：3 - 5年
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师、高级开发工程师 
- **扫码看解说**

Java中的4种引用类型包括强引用、软引用、弱引用、虚引用。它们主要体现对象不同的可达性状态和对GC（垃圾回收）的影响，以下是这4种引用类型的区别：

1. **强引用**：只要引用关系还在，对象就永远不会被回收。强引用其实就是指普通对象的引用，只要还有引用关系存在，就表示对象还活着，垃圾回收器就无法回收这一类对象。只有在没有其他引用关系或者超过引用作用域，再或者将对象引用强制赋值为null的情况下，垃圾回收器才会回收这个对象。

2. **软引用**：非必须存活的对象，JVM会在内存溢出前对其进行回收。软引用是一种相对于强引用来说弱一些的引用，可以让对象豁免一些垃圾回收的操作。只有当JVM判断内存不足的时候，才会试图回收引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足的时候就会清理掉，这样就可以保证在使用缓存的同时，不会耗尽内存。 

3. **弱引用**：非必须存活的对象，不管内存是否够用，下次GC一定回收。弱引用是相对于强引用而言的，它是在允许存在引用关联的情况下能被回收的对象。在垃圾回收线程扫描它所管辖的内存区域的过程中，一旦发现只具有弱引用的对象，不管当前的内存空间是否足够，垃圾回收器都会回收这个对象。 

4. **虚引用**：等同于没有引用，对象被回收时会收到通知。虚引用不会决定对象的生命周期，它提供一种确保对象被“finalize”以后去做某些事情的机制。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入与之关联的引用队列中，程序可以通过判断引用队列是否已经加入虚引用来决定被引用对象是否要被垃圾回收器回收。然后，我们就可以在引用对象被回收之前执行一些必要的操作。所以，虚引用必须和引用队列一起使用。 



通俗举例：

- 强引用就好比电视剧中的男主角，怎么都死不了。

- 软引用就像女主角，虽有一段经历，但还是没走到最后。 

- 弱引用就是男二号，注定是用来牺牲的。 

- 虚引用就是路人甲了。 



**面试点评**

这是一个好问题，如果要深度挖掘，还可以往对象的可达性状态分析及GC原理等方向展开。不过这确实也是一个比较偏门的问题，会更多地应用在一些类库或者框架里面。有兴趣的小伙伴可以进一步地深度研究它。



### 1.2.4 一个空的Object对象到底占多大内存

- **难度指数**：★★★★★

- **考查频率**：65%

- **开发年限**：3 - 5年

- **视频解说**：Tom

- **匹配岗位**：中级开发工程师、高级开发工程师 

- **扫码看解说**



以HotSpot虚拟机为例，一个对象在堆内存里面的内存布局使用OOP结构来表示，它主要由3部分组成，分别是对象头、实例数据和对齐填充：

1. **对象头**：包括Markword、类元指针、数组长度。其中Markword用来存储对象运行时的相关数据，比如hashCode、GC分代年龄等。在64位操作系统中占8字节，在32位操作系统中占4字节。类元指针指向当前实例对象所属哪个类，在开启压缩指针的情况下占4字节，未开启则占8字节。数组长度只有对象数组才会存在，占4字节。 

2. **实例数据**：主要用来存储对象中的字段信息。 

3. **对齐填充**：用来补充实现Java对象大小的倍数对齐。在JVM中，Java对象的大小需要按照8字节或者8字节的倍数来对齐，从而避免伪共享问题。 



总结：

1. 一个Java空对象，在开启压缩指针的情况下，占用12字节。其中，Markword占8字节、类元指针占4字节。但是为了避免伪共享问题，JVM会按照8字节的倍数进行填充，所以会在对齐填充区填充4字节，变成16字节。 

2. 在关闭压缩指针的情况下，Object默认会占用16字节。其中，Markword占8字节、类元指针占8字节。16字节正好是8的整数倍，因此不需要填充。 



一般情况下，一个空的Java Object对象会占用16字节的内存空间。



**面试点评**

这个问题不仅考查JVM基础，还考查求职者对JVM对象内存布局的理解，以及对对象头在Java内存中占用空间的理解。对于内存布局的理解可以帮助我们更好地解决应用JVM时的实际问题。



### 1.2.5 为什么重写equals()方法就一定要重写hashCode()方法

- **难度指数**：★★★★★

- **考查频率**：80%

- **开发年限**：3 - 5年

- **视频解说**：Mic

- **匹配岗位**：中级开发工程师、高级开发工程师 

- **扫码看解说**



先看String类的equals()方法源码片段：

```java
public boolean equals(Object anObject) {
    if (this == anObject) { //1.比较内存
        return true;
    }
    if (anObject instanceof String) { //2.比较字符串的值
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```
调用equals()方法比较两个对象时，会做两个操作：

1. 用==号比较两个对象的内存地址，如果地址相同，则返回true。 

2. 否则，继续比较字符串的值，如果两个字符串的值完全相等，则返回true。 



equals()方法和hashCode()方法的关系：


1. Java里任何一个对象都有一个“native”的hashCode()方法。 

2. 这个方法在散列集合中会用到，比如HashTable、HashMap，在添加元素的时候，需要判断元素是否存在，而如果用equals()方法，则效率太低，所以一般直接用对象的hashCode值进行取模运算。如果table中没有该hashCode值，它就可以直接存进去，不用再进行任何比较；如果存在该hashCode值，就调用它的equals()方法与新元素进行比较，相同的话就不存储了，不相同就散列其他地址，这样一来实际调用equals()方法的次数就大大减少了。hashCode的值默认是JVM使用随机数来生成的，两个不同的对象可能生成的hashCode相同，这种情况在Hash表里就是Hash冲突，通常会使用链表或者线性探测等方式来解决冲突问题。但是如果是两个完全相同的对象，也就是内存地址指向同一个，那么它们的hashCode一定是相同的。



理论情况下，如果x.equals(y)==true，假设没有重写equals()方法，那么这两个对象的内存地址是同一个，意味着hashCode必然相同。但如果只重写了equals()方法，就有可能导致hashCode不相同。一旦出现这种情况，就会导致这个类无法和所有集合类一起工作。所以在实际开发中，约定俗成了一条规则，重写equals()方法的同时也需要重写hashCode()方法。

如果只重写equals()方法，不重写hashCode()方法，就有可能导致a.equals(b)这个表达式成立，但是hashCode却不同。那么这个只重写了equals()方法的对象，在使用散列集合进行存储的时候就会出现问题。因为散列集合是使用hashCode来计算key的存储位置的，如果存储两个完全相同的对象，但是有不同的hashCode，就会导致这两个对象存储在Hash表的不同位置，当我们想根据这个对象去获取数据的时候，就会出现一个悖论。一个完全相同的对象会存储在Hash表的两个位置，造成按照大家约定俗成的规则出现一些不可预料的错误。

![image](https://github.com/user-attachments/assets/a7908e55-1853-4654-b4ed-69a7bae05f0a)


![image](https://github.com/user-attachments/assets/efa56168-3a98-4ace-abde-42c5bd4ee5d1)

**面试点评**

面试官想通过这个问题考查求职者对Java中Hash表的理解，以及对hashCode()方法和equals()方法之间关系的理解，其中还涉及Java对象的相等性判断、hashCode计算、Hash冲突方面的知识。在企业级开发中，一旦没有正确地使用这两个方法，将会带来灾难性的错误。因此再和小伙伴们强调一遍，Java基础真的很重要。 
