### 第2章 并发编程与多线程
#### 2.1 J.U.C和锁
##### 2.1.1 什么是AQS
- **难度指数**：★★★★
- **考查频率**：65%
- **开发年限**：3 - 5年
- **视频解说**：Mic
- **匹配岗位**：中级开发工程师、高级开发工程师
- **扫码看解说**


AQS是多线程同步器，它是J.U.C包中多个组件的底层实现，如Lock、CountDownLatch、Semaphore等都用到了AQS。从本质上来说，AQS提供了两种锁机制，分别是排他锁和共享锁。

排他锁，就是在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源。也就是多个线程中只能有一个线程获得锁资源，比如Lock中的ReentrantLock（重入锁）实现就用到了AQS中的排他锁功能。

共享锁也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如CountDownLatch和Semaphore都用到了AQS中的共享锁功能。


**面试点评**

面试官想通过这个问题考查求职者对Java并发编程的理解，特别是对AQS同步器的实现原理和使用方式的掌握情况，同时可以了解求职者对多线程同步的理解和使用经验，以及解决多线程并发问题的能力。

AQS是并发编程中比较核心的组件，掌握AQS的原理有助于理解Java并发编程的底层机制、实现高效的并发控制。在很多大厂面试中，面试官对并发编程的考核要求相对较高。简单来说，如果我们不懂并发编程，那么我们很难通过大厂高薪岗位的面试。


##### 2.1.2 如何理解AQS的实现原理
- **难度指数**：★★★★
- **考查频率**：80%
- **开发年限**：5年以上
- **视频解说**：Mic
- **匹配岗位**：高级开发工程师、系统架构师
- **扫码看解说**

AQS内部由两个核心部分组成：

![image](https://github.com/user-attachments/assets/a3a7fd28-023e-472d-937f-22dbae6be427)



1）一个volatile修饰的state变量，作为一个竞态条件。

2）用双向链表结构维护的FIFO线程等待队列。


它的具体工作原理是，多个线程通过对这个state共享变量进行修改来实现竞态条件，竞争失败的线程加入FIFO队列并且阻塞，抢占到竞态资源的线程释放资源之后，后续的线程按照FIFO顺序实现有序唤醒。

AQS里面提供了两种资源共享方式：一种是独占资源，同一个时刻只能有一个线程获得竞态资源，比如ReentrantLock就使用这种方式实现排他锁；另一种是共享资源，同一个时刻多个线程可以同时获得竞态资源，CountDownLatch或者Semaphore就使用共享资源的方式，实现同时唤醒多个线程。

**面试点评**

在实际开发中，如果我们需要实现一些特殊的互斥场景，直接使用ReentrantLock又有点麻烦，就可以自己集成AQS，自定义多线程竞争的实现逻辑。这个问题主要考查求职者对Java并发编程的理解。

##### 2.1.3 AQS为什么要使用双向链表
- **难度指数**：★★★★
- **考查频率**：60%
- **开发年限**：3年以上
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师
- **扫码看解说**

首
先，双向链表有两个指针，一个指针指向前置节点，另一个指针指向后继节点。所以，双向链表支持在O(1)时间复杂度下找到前置节点。因此，在进行插入和删除操作的时候，双向链表要比单向链表简单、高效。

从双向链表的特性来看，一般认为AQS使用双向链表有3个原因。


第1个原因，没有竞争到锁的线程加入阻塞队列，并且阻塞等待的前提是，当前线程所在节点的前置节点是正常状态，这样设计是为了避免链表中存在异常线程导致无法唤醒后续线程的问题。所以，线程阻塞之前需要判断前置节点的状态，如果没有指针指向前置节点，就需要从head节点开始遍历，性能非常低。

![image](https://github.com/user-attachments/assets/db86cb4e-3f3e-459a-a4d2-4befe8598d35)



第2个原因，在Lock接口里面有一个lockInterruptibly()方法，这个方法表示处于锁阻塞的线程允许被中断。没有竞争到锁的线程加入同步队列等待以后，是允许外部线程通过interrupt()方法触发唤醒并中断的。这个时候，被中断的线程的状态会修改成CANCELLED。而被标记为CANCELLED状态的线程，是不需要去竞争锁的，但是它仍然存在于双向链表。这就意味着在后续的锁竞争中，需要把这个节点从链表里移除，否则会导致锁阻塞的线程无法被正常唤醒。在这种情况下，如果是单向链表，就需要从head节点开始往下逐个遍历，找到并移除异常状态的节点，同样效率也比较低，还会导致锁的唤醒操作和遍历操作之间的竞争。

![image](https://github.com/user-attachments/assets/5db9a2bf-a43b-48b2-b949-3bd4b62f7432)


第3个原因，是为了避免线程阻塞和唤醒的开销，所以刚加入链表的线程，首先会通过自旋的方式尝试竞争锁。


但是实际上按照公平锁的设计，只有head节点的下一个节点才有必要去竞争锁，后续的节点竞争锁的意义不大。否则，就会造成羊群效应，也就是大量的线程在阻塞之前尝试去竞争锁，带来比较大的性能开销。所以，为了避免这个问题，加入链表中的节点在尝试竞争锁之前，需要判断前置节点是不是head节点，如果不是head节点，就没必要再去触发锁竞争的动作。所以这里会涉及前置节点的查找，如果是单向链表，那么这个功能的实现会非常复杂。


![image](https://github.com/user-attachments/assets/3c1d29ec-ee3e-43b1-9ba3-b36baca787bf)

![image](https://github.com/user-attachments/assets/5560560c-1f72-4b68-af1f-ca5704847464)


**面试点评**


对这个问题，有可能99%的人都回答不上来。面试官通过这个问题可以了解求职者对单向链表、双向链表的区别和特性的理解，同时可以判断求职者对AQS的理解深度。对AQS理解不深刻的人，可能不知道如何回答这个问题。要理解一种技术为什么这么设计，关键在于知道它需要解决什么样的问题。 


### 2.1.4 什么是CAS
- **难度指数**：★★★★
- **考查频率**：70%
- **开发年限**：3年左右
- **视频解说**：Mic
- **匹配岗位**：中级开发工程师
- **扫码看解说**

CAS是Java中Unsafe类里面的方法，它的全称是CompareAndSwap，是比较并交换的意思。它的主要功能是保证在多线程环境下，对于共享变量的修改的原子性。

举个例子，有这样一个场景，有一个成员变量state，默认值是0，定义了一个方法doSomething()，这个方法的逻辑是，判断state是否为0，如果为0，就修改成1。这个逻辑看起来没有任何问题，但是在多线程环境下，会存在原子性问题，因为这里是一个典型的Read-Write操作。一般情况下，我们会在doSomething()这个方法上加同步锁来解决原子性问题。

```java
public class Example {
    private int state = 0;
    public void doSomething() {
        if (state == 0) { //在多线程环境中，存在原子性问题
            state = 1;
            //TODO
        }
    }
}
```

但是，加同步锁会带来性能上的损耗，所以对于这类场景，我们就可以使用CAS来进行优化。下面是优化之后的代码，在doSomething()方法中，我们调用了Unsafe类中的compareAndSwapInt()方法来达到同样的目的，这个方法有4个参数，分别是当前对象实例、成员变量state在内存地址中的偏移量、预期值0和期望更改之后的值1。

```java
public class Example {
    private volatile int state = 0;
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long stateOffset;
    static {
        try {
            stateOffset = unsafe.objectFieldOffset
                    (Example.class.getDeclaredField("state"));
        } catch (Exception ex) {
            throw new Error(ex);
        }
    }
    public void doSomething() {
        if (unsafe.compareAndSwapInt(this, stateOffset, 0, 1)) {
            //TODO
        }
    }
}
```

CAS会比较state内存地址偏移量对应的值和传入的预期值0是否相等，如果相等，就直接修改内存地址中state的值为1，否则返回false，表示修改失败，而这个过程是原子的，不存在线程安全问题。

CAS是一个native方法，实际上它最终还是会面临同样的问题，就是先从内存地址中读取state的值，然后去比较，最后修改。这个过程不管在什么层面上实现，都会存在原子性问题。所以，在CAS的底层实现中，在多核CPU环境下，会增加一个Lock指令对缓存或者总线加锁，从而保证比较并替换这两个指令的原子性。

CAS主要用在并发场景中，比较典型的使用场景有两个。

1）J.U.C里Atomic的原子实现，比如AtomicInteger、AtomicLong。

2）实现多线程对共享资源竞争的互斥性质，比如AQS、ConcurrentHashMap、ConcurrentLinkedQueue等都有用到。

**面试点评**

CAS在并发编程中是一个非常重要的工具，通常的设计方法是将volatile+CAS组合使用，以实现多线程之间的同步竞争状态。在实际应用中，我们很少直接使用这类设计方法，所以大家对它比较陌生，但是它确实很重要，建议大家从更深的层次理解CAS的原理。

### 2.1.5 什么是乐观锁，什么是悲观锁
- **难度指数**：★★★★
- **考查频率**：80%
- **开发年限**：1 - 3年
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师
- **扫码看解说**

首先来看乐观锁。顾名思义，乐观锁就是持比较乐观态度的锁。乐观锁在操作数据时非常乐观，认为别的线程不会同时修改数据，所以不会上锁，但是在更新的时候会判断在此期间别的线程有没有更新过这个数据。

反之，悲观锁就是持悲观态度的锁。悲观锁在操作数据时比较悲观，每次操作数据的时候都认为别的线程也会同时修改数据，所以每次操作数据的时候都会上锁，这样别的线程想拿到这个数据就会阻塞，直到它拿到锁。


举个例子，有时候我们上公共厕所的时候要排队。

![image](https://github.com/user-attachments/assets/c7b3d465-274b-46ee-938c-863bf9aed4ef)


- 如果你蹲马桶的时候开着门，外面有人就会排着队看着你。你会这么做吗？当然，如果在自己家里，有可能会这么干，这就是乐观锁。虽然能进到房间，但是有人占着坑位，该排队还是得排队。比如数据库提供的write_condition机制，以及Java API并发工具包下面的原子变量类，就是使用了乐观锁的CAS来实现的。

- 悲观锁就不同了，就相当于进房间之后，第一件事就是把门锁上，在门外排队等候的人不知道里面发生了什么，又着急但是又只能干等着。比如行锁、表锁、读锁、写锁，都是在操作之前先上锁，Java API中的synchronized和ReentrantLock等独占锁都是悲观锁的实现。


根据前面对两种锁的介绍，总结一下两种锁的应用场景。

首先来看乐观锁，它适用于写少读多的情况，也就是说减少操作冲突，这样可以省去锁竞争的开销，提高系统的吞吐量。而悲观锁呢，它适用于写多读少的情况。因为，如果还使用乐观锁，会经常出现操作冲突，这样会导致应用层不断地重试，反而会降低系统的性能。

**面试点评**

在互联网公司的面试中，很多小伙伴都会被问到对锁的理解的问题。对于互斥锁、自旋锁、重入锁、读写锁、行锁、表锁等这些概念，我们可以把它们归纳为两种类型——乐观锁和悲观锁。

不管在什么场景中，锁的作用就是解决并发冲突。


### 2.1.6 什么条件下会产生死锁，如何避免死锁
- **难度指数**：★★★★
- **考查频率**：60%
- **开发年限**：3 - 5年
- **视频解说**：Tom
- **匹配岗位**：高级开发工程师
- **扫码看解说**

死锁，简单来说就是两个或者两个以上的线程在执行过程中，去争夺同一个共享资源导致相互等待的现象。如果没有外部干预，线程会一直处于阻塞状态，无法往下执行。这样一直等待处于阻塞状态的线程，被称为死锁线程。

![image](https://github.com/user-attachments/assets/4cdf52f2-11a4-409c-8b2d-516691c8cfb6)



产生死锁需要同时满足以下4个条件：

1）互斥条件，共享资源a和b只能被一个线程占用。

2）请求和保持条件，线程T1已经获得共享资源a，在等待共享资源b的时候，不释放共享资源a。

3）不可抢占条件，其他线程不能强行抢占线程T1占有的资源。

4）循环等待条件，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，形成了循环等待。


线程产生死锁之后，只能通过外部干预来解决问题，比如重启程序或者“Kill”线程。所以，我们只能在写代码时规避死锁的产生。那么如何避免死锁产生呢？根据产生死锁的4个条件，我们只需要破坏其中任何一个条件即可。
- 互斥条件是没有办法被破坏的，因为它是互斥锁的基本约束。其他3个条件都可以通过人工干预来破坏。
- 对于请求和保持条件，我们可以在首次执行时一次性申请所有的资源，这样就不存在等待锁的问题了。
- 对于不可抢占条件，占用部分资源的线程在进一步申请其他资源的时候如果申请不到，我们可以主动释放它占用的资源，这样不可抢占条件就被破坏了。
- 对于循环等待条件，可以通过按序申请资源来预防死锁的产生。按序申请，就是给资源编号，所有线程可以按照线性化的序号顺序申请共享资源，先申请序号小的，再申请序号大的，这样循环等待自然就不存在了。

**面试点评**

死锁问题一旦出现，就是比较严重的生产事故，所以大家在编写并发程序的时候，需要考虑可能发生死锁的情况，并提前规避。因此，死锁问题在初、中级程序员面试中也是比较常见的。

面试官通过这个问题考查求职者对多线程编程的理解，特别是死锁的实现原理和避免死锁的方法。掌握死锁的原理能更好地解决多线程并发问题，提高程序的运行效率和稳定性。

### 2.1.7 synchronized和Lock的区别是什么
- **难度指数**：★★★★
- **考查频率**：70%
- **开发年限**：3 - 5年
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师、高级开发工程师
- **扫码看解说**


synchronized和Lock都是Java中用来解决线程安全问题的工具，关于synchronized和Lock的区别，可以从以下4个方面来做一个详细的分析。

1. **特性区别**

synchronized是Java内置的一个线程同步关键字，而Lock是J.U.C包下面的一个接口，它有很多实现类，比如ReentrantLock就是它的一个实现类。

2. **用法区别**

synchronized可以写在需要同步的对象、方法或者特定代码块中。主要有两种写法：
```java
//控制方法
public synchronized void sync() {
}
```
```java
Object lock = new Object();
//控制代码块
public void sync() {
    synchronized(lock) {
    }
}
```

上面这种方式用来控制synchronized同步锁的作用范围。

Lock控制锁的粒度是通过lock()方法和unlock()方法来实现的。以ReentrantLock为例，来看这样一段代码：
```java
Lock lock = new ReentrantLock();
public void sync() {
    lock.lock(); //添加锁
    //TODO线程安全的代码
    lock.unlock(); //释放锁
}
```

这种方式，可以保证lock()方法和unlock()方法之间的代码是线程安全的。而锁的作用域，取决于Lock实例的生命周期。Lock在使用上相对来说比synchronized更加灵活一些。Lock可以自主地决定什么时候加锁，什么时候释放锁。只需要调用lock()和unlock()这两个方法就可以了。需要注意的是，为了避免程序异常导致锁没有释放的问题，一般我们将unlock()方法写在finally块中确保锁被释放。

另外，Lock还提供了非阻塞的竞争锁的方法tryLock()，这个方法可以通过返回true或者false来告诉当前线程是否已经有其他线程正在使用锁。而synchronized是关键字，无法扩展实现非阻塞竞争锁的方法，synchronized只有代码块执行结束或者代码出现异常时才会释放锁，因此它对锁的释放是被动的。

3. **性能区别**

synchronized和Lock在性能上差别不大，但在实现上有一些区别。synchronized采用的是悲观锁机制，是托管给JVM执行的，在JDK 1.6以后采用了偏向锁、轻量级锁、重量级锁及锁升级的方式进行优化。而Lock采用的是乐观锁机制，控制锁的代码用于自定义，也采用CAS自旋锁进行了优化。

4. **用途区别**

二者在一般情况下没有什么区别，但是在非常复杂的同步应用中，建议使用Lock。因为synchronized只提供了非公平锁的实现，而Lock提供了公平锁和非公平锁的机制。公平锁是指线程竞争锁资源的时候，如果已经有其他线程在排队等待锁，那么当前竞争锁的线程是无法插队的。而非公平锁就是不管其他线程是否在排队等待锁，它都会尝试竞争一次锁。

在实际应用中，线程及线程安全性是非常重要和常见的功能，对于这部分内容如果理解不够深刻，很容易造成生产级别的故障，这里专门整理了一张表格，帮助大家更好地理解这部分内容。


|内容|synchronized|Lock|
| ---- | ---- | ---- |
|特性|Java的关键字，在JVM层面|J.U.C包中的接口|
|获取|A获得锁，B等待。A阻塞，B一直等待|可尝试获得锁，线程不用一直等待|
|释放|执行完同步代码或者发生异常，被动释放|在finally块中释放锁，避免死锁|
|状态|无法判断|可以判断|
|类型|可以重入，不可中断，非公平|可重入，可判断，可公平，可非公平|
|性能|JDK 1.6以后性能有较大提升|性能差异不大|

**面试点评**

这个问题主要考查求职者对并发基础的掌握程度，在并发编程领域，如果一定要使用锁来解决并发安全问题，那么如何做好对性能和安全性的平衡，也是对开发人员技术底蕴的考验。

### 2.1.8 什么是可重入锁，它的作用是什么
- **难度指数**：★★★★
- **考查频率**：70%
- **开发年限**：1 - 3年
- **视频解说**：Mic
- **匹配岗位**：中级开发工程师
- **扫码看解说**

可重入是多线程并发编程里一个比较重要的概念。简单来说，就是在运行的某个方法或代码片段，因为抢占资源或者中断等原因，导致方法或者代码片段的运行中断，等待中断程序执行结束后，重新进入这个方法或者代码片段中运行，并且运行结果不会受到影响，那么这个方法或者代码片段就是可重入的。

而可重入锁，简单来说就是一个线程如果抢占到了互斥锁资源，在锁释放之前再去竞争同一把锁的时候，不需要等待，只需要记录重入次数。

下面的代码演示了synchronized同步锁的重入特性：
```java
public static synchronized void lock1() {
    //Thread X获得了lock1()中的synchronized锁
    //再次调用加同步锁的lock2()方法
    lock2();
}
public static synchronized void lock2() {
    //TODO
}
```

在多线程并发编程里，绝大部分锁都是可重入的，比如synchronized、ReentrantLock等，当然也有不支持重入的锁，比如Java 8里面提供的读写锁StampedLock。

锁的可重入性，主要用于避免线程死锁。因为一个已经获得同步锁X的线程，在释放锁X之前再去竞争锁X的时候，会出现自己要等待自己释放锁的情况，很显然这是无法成立的。

**面试点评**
这个问题其实是在考查求职者的基础知识。互联网大厂对基础知识的考查会特别深入，想进互联网大厂的小伙伴还需要在工作之外多花一点时间对这些知识进行研究。有3年工作经验的小伙伴，也应该开始关注这一类问题了。

### 2.1.9 ReentrantLock的实现原理是什么
- **难度指数**：★★★★
- **考查频率**：70%
- **开发年限**：3 - 5年
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师、高级开发工程师
- **扫码看解说**


ReentrantLock是一种可重入的排他锁，主要用来解决多线程对共享资源竞争的问题。

它有3个比较核心的特性：

1）它支持可重入，也就是获得锁的线程在释放锁之前再次去竞争同一把锁的时候，不需要加锁就可以直接访问。

2）它支持公平和非公平特性。

3）它提供了阻塞竞争锁和非阻塞竞争锁的两种方法，分别是lock()和tryLock()。


ReentrantLock的底层实现有几种非常关键的技术。

第1种，锁的竞争，ReentrantLock是通过互斥变量，使用CAS机制来实现的。 

![image](https://github.com/user-attachments/assets/f5aeeb40-4e28-4c66-8644-a29ad1c140cc)


### 2.1.9 ReentrantLock的实现原理是什么（续）

没有竞争到锁的线程，使用了AQS（AbstractQueuedSynchronizer）这样一个队列同步器来存储，底层是通过双向链表实现的。当锁被释放之后，会从AQS队列的头部唤醒下一个等待锁的线程。

第2种，公平和非公平的特性，主要体现在竞争锁的时候，需要判断AQS队列里是否存在等待中的线程。

第3种，锁的重入特性，在AQS里一个成员变量保存当前获得锁的线程，当同一个线程下次再来竞争锁的时候，就不会按照锁竞争的逻辑处理，而是直接增加重入次数。


**面试点评**

要回答好这个问题，有两个关键点：

1）必须要理解ReentrantLock的设计思想；

2）表达一定要清晰、有条理。

Java中很多基础组件的设计思想都非常有意思，值得我们深入学习。


### 2.1.10 ReentrantLock是如何实现锁的公平性和非公平性的
- **难度指数**：★★★★
- **考查频率**：80%
- **开发年限**：1 - 3年
- **视频解说**：Mic
- **匹配岗位**：中级开发工程师
- **扫码看解说**

这里先解释一下公平和非公平的概念。

1）公平，指的是竞争锁资源的线程，严格按照请求顺序来分配锁。

2）非公平，表示竞争锁资源的线程，允许插队来抢占锁资源。

ReentrantLock默认采用了非公平锁的策略来实现锁的竞争逻辑。

![image](https://github.com/user-attachments/assets/85fea8b1-77c7-41cc-a2f3-a5f778d5c615)


ReentrantLock内部使用了AQS来实现锁资源的竞争，没有竞争到锁资源的线程，会加入AQS同步队列，这个队列是一个FIFO的双向链表。

在这样的背景下，公平锁的实现方式就是，线程在竞争锁资源的时候判断AQS同步队列里有没有等待的线程。如果有，就加入队列的尾部等待。而非公平锁的实现方式就是，不管队列里有没有线程等待，它都会先尝试抢占锁资源，如果抢不到，则再加入AQS同步队列进行等待。

ReentrantLock和synchronized默认都是非公平的，之所以要这么设计，是因为考虑到了性能的问题。因为一个竞争锁的线程如果按照公平的策略去阻塞等待，同时AQS再把等待队列里的线程唤醒，会涉及内核态的切换，对性能的影响比较大。如果使用非公平策略，当前线程正好在上一个线程释放锁的临界点抢到了锁，就意味着这个线程不需要切换到内核态，虽然对原本应该被唤醒的线程不公平，但是提升了锁竞争的性能。

**面试点评**

公平性和非公平性的设计，在这么微小粒度的层面上去考虑性能问题，足以看到那些前辈们对程序设计的严谨态度。在面试的时候，求职者必须要回答出公平锁和非公平锁的特性，以及性能差异的底层原理。

### 2.1.11 说说你对行锁、间隙锁、临键锁的理解
- **难度指数**：★★★★★
- **考查频率**：90%
- **开发年限**：3年以上
- **视频解说**：Mic
- **匹配岗位**：中级开发工程师、高级开发工程师
- **扫码看解说**

行锁、间隙锁、临键锁，是MySQL里InnoDB引擎下解决事务隔离性的一系列排他锁。行锁，也称为记录锁，代码如下所示：
```sql
--其中id为主键索引
SELECT * FROM `test` WHERE `id` = 1 FOR UPDATE;
```
当我们针对主键或者唯一索引加锁的时候，MySQL默认会对查询的这一行数据加行锁，避免其他事务对这一行数据进行修改。

间隙锁，顾名思义，就是锁定一个索引区间。


在普通索引或者唯一索引列上，由于索引是基于B+树的结构存储的，所以默认会存在一个索引区间。

创建表及插入数据示例：
```sql
CREATE TABLE `test` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(8) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `test` VALUES ('1', '小A');
INSERT INTO `test` VALUES ('5', '小B');
INSERT INTO `test` VALUES ('7', '小C');
INSERT INTO `test` VALUES ('11', '小D');
```
默认存在的间隙锁区间：`(-∞, 1); (1,5); (5,7); (7,11); (11,+∞)`

![image](https://github.com/user-attachments/assets/d53ce00e-1d5c-4d67-b07f-4e1b51372693)


某个事务对索引列加间隙锁的时候，默认锁定对应索引的左右开区间范围。

基于索引列的范围查询，无论是否是唯一索引，都会自动触发间隙锁。比如基于between的范围查询，就会产生一个左右开区间的间隙锁。

最后一个是临键锁，代码如下所示：
```sql
--锁定:(5, 7)
SELECT * FROM `test` WHERE `id` BETWEEN 5 AND 7 FOR UPDATE;
```
它相当于行锁+间隙锁的组合，也就是它的锁定范围既包含了索引记录，也包含了索引区间。它会锁定一个左开右闭区间的数据范围。

创建表及插入数据示例：
```sql
CREATE TABLE `test` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(8) DEFAULT NULL,
  `age` int(4) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_age` (age)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `test` VALUES(1,'小A',10);
INSERT INTO `test` VALUES(2,'小B',11);
INSERT INTO `test` VALUES(3,'小C',13);
INSERT INTO `test` VALUES(4,'小D',20);
```
age字段临键锁区间：`(-∞,10]; (10,11]; (11,13]; (13,20]; (20,+∞)`

![image](https://github.com/user-attachments/assets/e34d0721-2543-400a-a295-6ee0cc80a878)


假设我们使用非唯一索引列进行查询，默认会加一个临键锁，锁定一个左开右闭区间的范围，代码如下所示：
```sql
--临键锁，锁定区间(10,11]
select * from test where age=11 for update;
```

总的来说，行锁、间隙锁、临键锁只是表示锁定数据的范围，最终目的是解决幻读的问题。临键锁相当于行锁+间隙锁，因此当我们使用非唯一索引进行精准匹配的时候，会默认加临键锁，因为它需要锁定匹配的这一行数据，还需要锁定这一行数据对应的左开右闭区间。因此在实际应用中，尽可能使用唯一索引或者主键索引进行查询，避免锁定范围太大影响性能。

**面试点评**

关于数据库里的事务隔离级别，以及解决隔离级别问题的底层原理，在面试中也非常常见。比如，掌握MySQL里多种类型锁，除了对应面试有用，对实际应用开发也有很好的指导意义，也就是说，要在保证数据安全性的同时保证性能。

### 2.1.12 如何理解Java中令人眼花缭乱的各种并发锁
- **难度指数**：★★★★
- **考查频率**：80%
- **开发年限**：3年以上
- **视频解说**：Tom
- **匹配岗位**：中级开发工程师、高级开发工程师
- **扫码看解说**

在并发编程中，经常会遇到两个以上的线程访问同一个共享变量的情况，当同时对共享变量进行读写操作时，就会产生数据不一致的情况。随着线程并发技术的发展，在多线程环境中，对线程访问资源的限制也越来越多。为了保证资源获取的有序性和占用性，我们通常是通过并发锁来进行控制的。

笔者根据个人经验及并发场景中线程的处理逻辑，可以总结为以下7种情况，不同情况使用不同的锁。
1. **某个线程是否锁住同步资源**

如果要锁住同步资源则使用悲观锁，不锁住同步资源则使用乐观锁。

- 悲观锁就是每次拿数据的时候都认为会有别人修改数据，所以在读数据的时候都会上锁，其他线程就会阻塞，直到拿到锁。
    
![image](https://github.com/user-attachments/assets/d88080b1-3a3d-403b-959f-6e95206c7204)

    
- 乐观锁就是每次拿数据的时候都假设别人不会修改数据，所以不会上锁；只是在更新数据的时候判断之前有没有别的线程更新了这个数据。如果这个数据没有更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新了，要么报错，要么自动重试。

![image](https://github.com/user-attachments/assets/a39f9ea1-0d0e-46e7-a331-6ba0c334d675)


实际上乐观锁与悲观锁是一种广义上的概念，没有谁优谁劣。乐观锁适用于写少读多的场景，因为不用上锁、释放锁，省去了锁的开销，从而提升了吞吐量。而悲观锁适用于写多读少的场景，因为线程间竞争激烈，如果使用乐观锁会导致线程不断进行重试，这样反而降低了性能。

2. **多个线程是否共享一把锁**


在并发情况下，如果多个线程共享一把锁，就使用共享锁，如果不能共享一把锁，那就使用独占锁，也叫排他锁或独享锁。
- 共享锁是指锁可被多个线程所持有。如果一个线程对数据加上共享锁，那么其他线程只能对数据再加共享锁，不能加独占锁。获得共享锁的线程只能读数据，不能修改数据。
-
- 在JDK中，ReentrantReadWriteLock就包含共享锁的实现。

![image](https://github.com/user-attachments/assets/a5024262-3c6c-4897-a57a-7d8eef2b706d)


- 独占锁是指锁一次只能被一个线程所持有。如果一个线程对数据加上独占锁，那么其他线程不能再对该数据加任何类型的锁。获得独占锁的线程既能读数据又能修改数据。在JDK中，synchronized和J.U.C包中Lock的实现类都是独占锁。

![image](https://github.com/user-attachments/assets/5811c530-aa41-416a-8075-85a154763256)

    
- 互斥锁是独占锁的一种常规实现，是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。互斥锁一次只能被一个线程拥有，其他线程只能等待。

![image](https://github.com/user-attachments/assets/87e4b103-607c-45de-98ba-fb022bdb2ac1)


- 读写锁是共享锁的一种具体实现。读写锁管理一组锁，一个是只读的锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，而写锁是独占的。写锁的优先级要高于读锁，一个获得了读锁的线程必须能看到前一个释放的写锁更新的内容。读写锁相对于互斥锁的并发程度更高，每次只有一个写线程，但是同时可以有多个线程并发读。JDK中定义了一个读写锁的接口ReadWriteLock，源码如下所示：

![image](https://github.com/user-attachments/assets/328d6580-3fd2-4d66-aa4c-1965fbe6a95e)


```java
public interface ReadWriteLock {
    /* 获取读锁 */
    Lock readLock();
    /* 获取写锁 */
    Lock writeLock();
}
```
ReentrantReadWriteLock实现了ReadWriteLock接口，ReentrantReadWriteLock支持锁降级，不支持锁升级，可以由写锁降为读锁。

3. **多个线程竞争时是否要排队**

多个线程竞争排队获取锁的情况，可以使用公平锁，也可以使用非公平锁。

![image](https://github.com/user-attachments/assets/361a1109-1dac-4f13-af0b-4b2dd9b0bef8)


- 公平锁是指多个线程按照申请锁的顺序来获取锁，类似排队买票，先来的人先买，后来的人在队尾排着。在Java中可以通过构造函数初始化公平锁，代码如下所示：
```java
/**
 * 创建一个可重入锁，
 * true表示公平锁，
 * false表示非公平锁。
 * 默认为非公平锁
 */
Lock lock = new ReentrantLock(true);
```
- 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序进行的，有可能后申请的线程比先申请的线程优先获得锁，在高并发环境下，有可能造成优先级翻转，或者某个线程一直得不到锁的饥饿状态。在Java中synchronized关键字是非公平锁，ReentrantLock默认也是非公平锁，如下代码所示：

![image](https://github.com/user-attachments/assets/8958fa9e-7264-46ee-aa04-03bfbf7b6104)


```java
/** 创建一个可重入锁，true表示公平锁，false表示非公平锁。默认为非公平锁*/
Lock lock = new ReentrantLock(false);
```

4. **一个线程中的多个流程是否能获取同一把锁**


如果一个线程中的多个流程能获取同一把锁，就使用可重入锁；如果一个线程中的多个流程不能获取同一把锁，就使用不可重入锁。


可重入锁又称递归锁，是指同一个线程在外层方法获取了锁，在进入内层方法时会自动获取锁。

![image](https://github.com/user-attachments/assets/bece6b17-ffdc-4cd6-a5bd-ec3bed95ae4f)


对于Java ReentrantLock而言，从它的名字就可以看出，它是一个可重入锁。synchronized也是一个可重入锁。可重入锁的一个好处是可在一定限度上避免死锁。以synchronized为例，来看这样一段代码：


```java
public synchronized void methodA() throws Exception{
    // Do some magic tings
    methodB();
}
public synchronized void methodB() throws Exception{
    // Do some magic tings
}
```
在这段代码中，methodA()调用methodB()，如果一个线程调用methodA()已经获取了锁，再调用methodB()就不需要再次获取锁了，这就使用了可重入锁的特性。如果是不可重入锁，则methodB()可能不会被当前线程执行，造成死锁。

5. **某个线程锁住同步资源失败，该线程是否阻塞**

如果某个线程锁住同步资源失败，但是希望这个线程不阻塞，就可以使用自旋锁或者自适应自旋锁。

![image](https://github.com/user-attachments/assets/3341314c-1248-489b-bc5d-b51147135658)


- 自旋锁是指线程在没有获得锁时不是被直接挂起，而是执行一个忙循环，这个忙循环就是自旋。自旋锁的目的是减小线程被挂起的概率，因为线程的挂起和唤醒也都是耗费资源的。如果锁被另一个线程占用的时间比较长，即使自旋了，之后当前线程还是会被挂起，忙循环就会变成浪费系统资源的操作，反而降低了整体性能。因此自旋锁是不适合锁占用时间长的并发情况的。在Java中，AtomicInteger类就有自旋的操作，来看这样一段代码：
```java
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
```
循环条件调用compareAndSwapInt()方法，被称为CAS操作，如果失败，就会一直循环获取当前value值然后重试，这个过程叫作自旋。


- JDK 1.6引入了自适应自旋，这就比较智能了，自旋时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果虚拟机认为这次自旋很有可能再次成功，那就会自旋较多的时间，如果自旋很少成功，那以后可能就会直接省略自旋过程，避免浪费处理器资源。

6. **线程竞争同步资源时，细节流程是否发生变化**


JDK 1.6为了提升性能、减少获得锁和释放锁带来的资源消耗，引入了4种锁的状态：无锁、偏向锁、轻量级锁、重量级锁，并且锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，但是锁的升级是单向的，不能降级。
    - 无锁：无锁的状态就是没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。在Java中，原子类操作就是通过无锁的方式实现的，例如AtomicInteger的自增操作，它使用了CAS（Compare And Swap）操作，在更新数据时比较当前值和期望值，如果相等则更新，否则重试，这个过程没有加锁。
    - 偏向锁：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。当一个线程访问同步代码块并获取偏向锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID。以后该线程进入和退出同步代码块时不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁；如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
    - 轻量级锁：轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的方式尝试获取锁，不会阻塞，从而提高性能。当线程进入同步代码块时，如果同步对象锁状态为无锁状态（锁标志位为“01”，是否偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。如果更新操作失败，则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有了这个对象的锁，直接进入同步代码块；否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志位变为“10”，此时会阻塞等待锁的释放。
    - 重量级锁：重量级锁是指当锁竞争变得激烈，轻量级锁自旋超过一定次数或者持有锁的线程执行时间过长等情况时，轻量级锁就会升级为重量级锁，此时会阻塞等待锁的释放。重量级锁通过使用操作系统的互斥量（mutex）来实现，线程获取不到锁时会进入阻塞状态，这会涉及用户态到内核态的切换，开销较大。

7. **锁的获取和释放是否需要手动管理**
如果



### 6. 线程竞争同步资源时，细节流程是否发生变化
JDK 1.6为了提升性能、减少获得锁和释放锁带来的资源消耗，引入了4种锁的状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着多线程的竞争情况逐渐升级，但不能降级。

![image](https://github.com/user-attachments/assets/71fd5efc-874e-4e31-9168-bdaa005c132d)


如果多个线程中，只有一个线程能够修改资源成功，其他线程只是重试，不锁住资源，这种状态称为无锁状态，其实就是乐观锁。

![image](https://github.com/user-attachments/assets/3a696911-ef15-4753-8f97-7f9d5fb6a699)


第一个线程访问加锁的资源自动获取锁，不存在多线程竞争的情况，资源偏向于第一个访问锁的线程，每次访问线程都不需要重复获取锁，这种状态称为偏向锁。偏向锁是通过控制对象Mark Word的标志位来实现的，如果当前是可偏向状态，则需要进一步判断对象头存储的线程ID是否与当前线程ID一致，如果一致则直接进入。

当线程竞争变得比较激烈时，偏向锁就会升级为轻量级锁。轻量级锁认为虽然竞争是存在的，但是在理想情况下竞争的程度很低，所以通过自旋方式等待上一个线程释放锁。

如果线程并发进一步加剧，线程的自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问，轻量级锁就会膨胀为重量级锁，重量级锁会使除当时拥有锁的线程外的所有线程都阻塞。升级到重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。

在Java中，synchronized关键字的内部实现原理就是这样一个锁升级的过程。

### 7. 锁再设计和锁优化

先来看看分段锁，它是一种锁的再设计，并不是具体的一种锁。


分段锁的设计目的是将锁的粒度进一步细化，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。在Java中，ConcurrentHashMap 1.7底层使用分段锁Segment，来支持多线程并发操作。

![image](https://github.com/user-attachments/assets/b92673b8-5e03-48cd-81d2-056d8b433cc9)


另外，就是锁优化，包括锁粗化和锁消除。锁粗化就是将多个同步块的数量减少，并将单个同步块的作用范围扩大，本质上就是将多次上锁、解锁的请求合并为一次同步请求。举个例子，一个循环体中有一个代码同步块，每次循环都会执行加锁解锁操作：
```java
private static final Object LOCK = new Object();
for(int i = 0; i < 100; i++) {
    synchronized(LOCK){
        // do some magic things
    }
}
```
经过锁粗化后，就变成下面这个样子：
```java
synchronized(LOCK){
    for(int i = 0; i < 100; i++) {
        // do some magic things
    }
}
```

锁消除是指虚拟机编译器在运行时检测到共享数据没有竞争的锁，从而将这些锁进行消除。举个例子让大家更好理解，来看这样一段代码：
```java
public String test(String s1, String s2){
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append(s1);
    stringBuffer.append(s2);
    return stringBuffer.toString();
}
```
上面代码中的test()方法的主要作用是将字符串s1和字符串s2串联起来。test()方法中的3个变量s1、s2和StringBuffer都是局部变量，局部变量是存储在栈上的，而栈又是线程私有的，所以就算有多个线程访问test()方法，也是线程安全的。

我们都知道StringBuffer是线程安全的类，因为append()方法是同步方法：
```java
// append()是同步方法
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
```
但是test()方法本来就是线程安全的，为了提升效率，虚拟机自动帮我们消除了这些同步锁，这个过程就被称为锁消除。

**面试点评**
前面讲了这么多，相信大家已经理解了令人眼花缭乱的各种锁。这里用一张脑图完整地总结各种锁的应用场景。大家可以在面试前拿出来看看，这样只要被问到锁相关的问题，一定能够“吊打”面试官。

### Java中各种锁脑图内容
- **某个线程是否锁住同步资源**
    - 锁住：悲观锁
    - 不锁住：乐观锁
- **多个线程是否共享一把锁**
    - 共享：共享锁
    - 不共享：独占锁（排他锁、独享锁）
- **多个线程竞争时是否要排队**
    - 排队：公平锁
    - 先尝试插队，插队失败再排队：非公平锁
- **一个线程中的多个流程是否能获取同一把锁**
    - 能：可重入锁
    - 不能：不可重入锁
- **某个线程锁住同步资源失败，该线程是否阻塞**
    - 阻塞： - 
    - 不阻塞：自旋锁、自适应自旋锁
- **线程竞争同步资源时，细节流程是否发生变化**
    - 不锁住资源，多个线程中只有一个线程能修改资源成功，其他线程会重试：无锁
    - 第一个线程访问加锁的资源自动获取锁，该线程每次访问不需要重复获取锁：偏向锁
    - 多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放：轻量级锁
    - 多个线程竞争同步资源时，没有获取资源的线程阻塞等待唤醒：重量级锁
- **锁再设计和锁优化**
    - 再设计：细化锁的粒度 - 分段锁
    - 锁优化：
        - 将锁的作用范围扩大 - 锁粗化
        - 虚拟机自动消除没有竞争的锁 - 锁消除

![image](https://github.com/user-attachments/assets/fc9acb83-db91-4ba4-881b-8653394cedb2)
